
public class Point {
    public double x;
    public double y;
    public double z;

    public Point(double xx, double yy, double zz) {
         x = xx;
         y = yy;
         z = zz;
    }

    public void DebugPrint(String mystr) {
         System.out.println(mystr + x + "," + y + "," + z);
    }
	
	//this point is the origin
	public Vector CalculateCrossProduct(Point P, Point Q) {

        //Z positive means visible
        //Z negative means hidden because behind stuff
        //Z 0 means shows as a line or dot
		
		//this point is the origin
        Vector P_vector = new Vector(P.x - this.x, P.y - this.y, P.z - this.z);
        Vector Q_vector = new Vector(Q.x - this.x, Q.y - this.y, Q.z - this.z);

        double answer_X = (P_vector.y * Q_vector.z) - (P_vector.z * Q_vector.y);
        double answer_Y = (P_vector.z * Q_vector.x) - (P_vector.x * Q_vector.z);
        double answer_Z = (P_vector.x * Q_vector.y) - (P_vector.y * Q_vector.x);

        Vector answer = new Vector(answer_X, answer_Y, answer_Z);
        return answer;
   }
   
   
   
   
      
      
   /****************************************************************************************************
   A perspective projection that maps x and y coordinates
   to the correct place on the projection plane while
   maintaining depth information is achieved by mapping the view frustrum to a cube.
   The cube called "homogenous clip space" is centered at the originin OpenGL
   and extends from -1 to +1 on each of the x, y, and z axes.
   
   The mapping to homogenous clip space is performed using a 4x4 projection
   matrix that, among other actions, places the negative z-coordinate of a
   camera-space point into the w-coordinate of the transformed point.
   Subsequent division by the w-cooridnate produces a 3-dimensional point that lies in clip space.
   
   Let P = <Px, Py, Pz, 1> be a homogenous point in camera-space that lies inside the view frustrum.
   The OpenGL function glFrustrum() takes as parameters the left edge x=l,
   the right edge x=r, the bottom edge y=b, and the top edge y=t of the rectangle
   carved out of the near plane by the four side planes of the vuew frustrum.
   The near plane lies at z=-n, so we can calculate the projected X and y coordinates
   of the point P on the near plane using the equations
   
   x = - (n/Pz)(Px)  and   y = - (n/Pz)(Py)
   
   Any point in lying in the view frustrum satisfies l <= x <= r
   and b <= y <= t on the near plane.  We want to map these ranges to the [-1,1] range
   needed to fit the view frustrum into homogenous clip space.....
   
   Mapping the projected z-coordinate to the range -1 to 1 involves somewhat
   more complex computation. Since the point P lies inside the view frustrum,
   its z-coordinate must satisfy -f <= z <= -n, where n and f are the distances
   from the camera to the near and far planes, respectively.
   We wish to find a function that maps -n --> -1 and -f --> 1.
   (Note that such a mapping reflects the z-axis; therefore
   homogenous clip space is left-handed.)
   
         |  2n/(r-l)      0         (r+l)/(r-l)        0      |
         |                                                    |
         |  0            2n/(t-b)   (t+b)/(t-b)        0      |
    P' = |                                                    | P
         |  0             0         -(f+n)/(f-n)   -2nf/(f-n) | 
		 |                                                    |
		 |  0             0            -1              0      |
		
		
	P' = <-x'Pz, -y'Pz, -z'Pz, -Pz>
	
	divide that by the w-coordinate which is -Pz and you get
	
	<x', y', z'>
		
	This matrix is the OpenGL perspective projection matrix
	generated by the glFrustrum() function.  Camera-space points
	are transformed by this matrix into homogenous clip coordinates
	in such a way that the w-coordinate holds the negation of the original camera-space Z-coordinate.
	***************************************************************************************************/
	public Point TransformViewFrustrumToClipSpace(double far, double near, double left, double right, double top, double bottom) {
		
		//The point this method is called on is the camera_space_point
		double f = far;
		double n = near;
		double l = left;
		double r = right;
		double t = top;
		double b = bottom;
		
		//transform x-coord to [-1,1] in clipping-space
		double clip_space_point_X = (((2 * n)/(r - l)) * this.x) + (((r+l)/(r-l)) * this.z);
		
		//transform y-coord to [-1,1] in clipping-space
		double clip_space_point_Y = (((2 * n)/(t - b)) * this.y) + (((t+b)/(t-b)) * this.z);
		
		//transform z-coord to [-1,1] in clipping-space
		double clip_space_point_Z = ((-1 * ((f+n)/(f-n))) * this.z) + ((-2 * n * f)/(f-n));
		
		//NOW DIVIDE BY -Pz
		double temp = ((-1)*this.z);
		clip_space_point_X = clip_space_point_X / temp;
		clip_space_point_Y = clip_space_point_Y / temp;
		clip_space_point_Z = clip_space_point_Z / temp;
		
		Point clip_space_point = new Point(clip_space_point_X, clip_space_point_Y, clip_space_point_Z);
		return clip_space_point;
	}//TransformViewFrustrumToClipSpace
	
	

    /**************************************************************************
	Orthographic Projection
	
	      | 2/(r-l)         0             0              (r+l)/(r-l) |
	      |                                                          |
	      | 0             2/(t-b)         0              (t+b)/(t-b) |
	P' =  |                                                          |  P
	      | 0               0            -2/(f-n)        (f+n)/(f-n) |
		  |                                                          |
		  | 0               0             0               1          |
		  
	this matrix is the OpenGL orthographic projection matrix generated by the 
	glOrtho() function.  Note that the w-coordinate remains 1 after the transformation,
	and thus no perspective projection takes place.
	
	(so if (right) r == +1  and  (left) l == -1  for x-axis-planes
	 and if  (top) t == +1 and (bottom) b == -1  for y-axis planes
	 and if (near) n and (far) f for z-axis planes
	 then the matrix becomes  |  1     0         0             0  |
	                          |  0     1         0             0  |
							  |  0     0    (negative number)  0  |
							  |  0     0         0             1  |
	 
	 which means the x-coord and y-coord do not change
	**************************************************************************/

   
   
   //Math.sin and Math.cos take angle in radians
   /***************************************
     cos   -sin   0
     sin   cos    0
     0     0      1
   ****************************************/
   public void Rotate_Around_Z_Axis(double angle_in_radians) {

        double XX = (Math.cos(angle_in_radians) * this.x) - (Math.sin(angle_in_radians) * this.y);
        double YY = (Math.sin(angle_in_radians) * this.x) + (Math.cos(angle_in_radians) * this.y);

        this.x = XX;
        this.y = YY;
        //this.z  is unchanged
   }

   /***************************************
      1     0     0
      0     cos   -sin
      0     sin   cos
   ***************************************/
   public void Rotate_Around_X_Axis(double angle_in_radians) {

        double YY = (Math.cos(angle_in_radians) * this.y) - (Math.sin(angle_in_radians) * this.z);
        double ZZ = (Math.sin(angle_in_radians) * this.y) + (Math.cos(angle_in_radians) * this.z);

        //this.x  is unchanged
        this.y = YY;
        this.z = ZZ;
   }

   /****************************************
      cos    0     sin
      0      1     0
      -sin   0     cos
   ******************************************/
   public void Rotate_Around_Y_Axis(double angle_in_radians) {

        double XX = (Math.cos(angle_in_radians) * this.x) + (Math.sin(angle_in_radians) * this.z);
        double ZZ = (Math.cos(angle_in_radians) * this.z) - (Math.sin(angle_in_radians) * this.x);

        this.x  = XX;
        //this.y is unchanged
        this.z  = ZZ;
   }

}//class Point

